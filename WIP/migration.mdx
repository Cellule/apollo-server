
# Migrating to Apollo Server 4 (Alpha)

Apollo Server 4 is now out in [alpha](/docs/resources/release-stages).

The focus of this major release is to improve Apollo Server's extensibility and make it simpler to use, maintain, and document. To learn more about the inspiration behind this release, see the [Apollo Server Roadmap](https://github.com/apollographql/apollo-server/blob/main/ROADMAP.md)

Apollo Server 4's alpha provides the following features, with more to come with the full release:
<!-- TODO: fill in -->


<!-- Do we want this? -->
During Apollo Server 4's alpha we are actively looking to gather feedback and [issues](https://github.com/apollographql/apollo-server/issues/new/choose) from community members and customers.

## Bumped dependencies

### Node.js
Apollo Server 4 supports Node.js 14 and later. This includes all [LTS and Current versions at the time of release](https://nodejs.org/en/about/releases/).

If you're using an older version of Node.js, upgrade your runtime before upgrading to Apollo Server 4.

### `graphql`

Apollo Server has a peer dependency on `graphql` (the core JS GraphQL implementation), which means you are responsible for choosing the version installed in your app.

Apollo Server 4 supports `graphql` v16.3.0 and later. (Apollo Server 3 supported `graphql` v15.3.0 through v16.)

If you're using an older version of `graphql`, upgrade it to a supported version before upgrading to Apollo Server 4.

## Removed constructor options

The follow `ApolloServer` constructor options have been removed in favor of other configuration methods.

<!-- TODO FIGURE OUT WHAT'S UP HERE -->
### `dataSources`

Apollo Sever 4 removes the `dataSources` constructor option. The type returned from your context function matches the type available as context in your resolvers and plugins instead of the latter having an extra dataSources piece on it.

You can still add data sources to your context,

Replace top-level dataSources option with a data sources plugin

RESTDataSource and friends are still cool things to put in your context. But just put them on your context yourself.
https://github.com/apollographql/apollo-server/issues/6047#issuecomment-1115739665
for examples

The `apollo-datasource` package (with the DataSource abstract class) is no longer maintained.
`RESTDataSource` will be published in a new package name (`@apollo/data-source-rest`? `@apollo/rest-data-source`?) (tbd)

No more dataSources constructor option. The type returned from your context function matches the type available as context in your resolvers and plugins instead of the latter having an extra dataSources piece on it.

### `modules`
In Apollo Server 3 there are [several ways](https://github.com/apollographql/apollo-server/issues/6062) to provide your `ApolloServer` instance with a schema. One of these ways was by using a `modules` constructor option, which under the hood uses the `buildServiceDefinition` function from the `@apollographql/apollo-tooling` library, to specify a schema using an array of `typeDefs` and `resolvers` objects.

To simplify the Apollo Server 4 API, we removed the `modules` constructor option and recommend that developers use the following syntax to create a schema when creating a new `ApolloServer` instance:
```js
  new ApolloServer({
    typeDefs: modules.map({ typeDefs } => typeDefs,
    resolvers: modules.map({ resolvers } => resolvers,
  })
```

## Removed features

### Dropped support for older versions of the gateway

Apollo Server 4 drops support for [`@apollo/gateway` versions](/federation/api/apollo-gateway/) below v0.35.0.

#### Dropping Redundant Gateway TypeScript types

In Apollo Server 2, the TypeScript type used for the `gateway` constructor option is called `GraphQLService`. Apollo Server 3 introduced a new TypeScript type called `GatewayInterface`.

Apollo Server 4 will drop exporting the `SchemaChangeCallback` and `GraphQLService` types, we recommend using the `GatewayInterface` type instead.

This `GatewayInterface` requires the following:

- The `stop` method must be present.
- The `executor` method must async
- The `apollo` option must always be passed to the `load` method.


### `__resolveObject`

In Apollo Server 4 we removed the dependency on `@apollographql/apollo-tooling`, in the process removing the `__resolveObject` pseudo-resolver. The `__resolveObject` function was a predecessor to
the [`__resolveReference`](/federation/api/apollo-subgraph/#__resolvereference) method.

### Remove features that wrap framework-specific libraries

Apollo Server 3 includes core-maintained bindings for several web frameworks and serverless environments. These bindings are all maintained by the Apollo Server core team, but we do not have practical experience running servers that use most of these frameworks.

One of the driving focuses behind Apollo Server 4  is creating a stable and simple API, enabling developers to easily create their own integrations for new frameworks.

Removed most web framework integrations from the core
Removed:
- "packages/apollo-server-fastify",
- "packages/apollo-server-hapi",
- "packages/apollo-server-koa",
- "packages/apollo-server-lambda",
- "packages/apollo-server-micro",
- "packages/apollo-server-cloud-functions",
- "packages/apollo-server-cloudflare",
- "packages/apollo-server-azure-functions",


We are looking for volunteers to maintain these integrations! See the [issues with the 'integration-collaborators' label](https://github.com/apollographql/apollo-server/labels/integration-collaborators) to find the discussion about your favorite web framework today.

### Remove body-parser & CORS wrapping
In Apollo Server 4, framework integration functions won't try to wrap these basic framework-specific libraries. If you want to use our Express middleware, you'll be required to use the standard body-parser middleware yourself. (We'll have good error handling to help you figure out if you forgot to do this.) This means we won't have to have a special option just for passing options through to body-parser.

ApolloServerStandalone (our replacement for the batteries-included apollo-server package) will still link in body-parser and parse bodies for you. Any integration maintainer who thinks their package would work better if it had a more standalone/batteries-included API should feel free to add that as well, but the main building block exported by an integration should probably just handle GraphQL requests without linking in other middleware.

> (except from standaloneServer, but even that one you can’t configure)

### Remove health checks and path parsing
The “health check” feature is just "an HTTP path which always returns 200 and which allows you to pass in a handler to run arbitrary code instead". It’s notably not actually connected to the state of the ApolloServer object itself (eg, if something is broken that prevents operations from executing then health checks can still pass). Our docs (https://www.apollographql.com/docs/apollo-server/monitoring/health-checks/) no longer actively encourage the use of this feature and instead recommend running a trivial GraphQL query over GET. If for some reason running this query is not an acceptable health check, folks integrating Apollo Server into a web framework can define their own health check via their web framework directly.

This feature is the main remaining reason that ApolloServer needs to know about and parse URI paths. This leads to a bunch of confusing complexity: there’s a concept of server.graphqlPath which middleware uses to decide whether or not to process a request as GraphQL, but you can also use your web framework itself to specify directly what path middleware is mounted at. (This flexibility is not provided to the batteries-included server, which always has a graphqlPath of /.) Path parsing has been a challenge for many integrations; for example, when running in AWS Lambda, the full path at which your function is invoked generally contains some extra components which need to be ignored to figure out if the request is a health check.

So if we’re removing health checks from Apollo Server, we can also remove path parsing; if you want to mount your GraphQL server at /api/graphql, you should do that via app.use('/api/graphql', apolloServer.getMiddleware()) rather than via app.use(apolloServer.getMiddleware({ graphqlPath: '/api/graphql' })) (both of which currently work with slightly and confusingly different semantics).

We may consider leaving health check support in ApolloServerStandalone (where you can't easily add your own HTTP path handlers), if compelling arguments for why it's superior to using `?query=%7B__typename%7D` as health check are provided.

No health checks, run a trivial GraphQL operation or do your own health check.
Middlewares work on any path they get to see. If you want to run GraphQL on a non-root path, use your web framework’s functionality for mounting the middleware at the path. (Previously, the middlewares defaulted to only processing `/graphql`, and the standalone server processed all requests.)

## Removed Integrations

### `apollo-server` npm package is now `standaloneServer` function

```ts
import { ApolloServer, standaloneServer } from "@apollo/server";

interface MyContext {
  token: string;
}

const apolloServerInstance = new ApolloServer<MyContext>({
  typeDefs,
  resolvers,
});
const { url } = await standaloneServer(apolloServerInstance, {
  context: async (req, _res) => ({
    token: await getTokenForRequest(req),
  }),
}).listen({ port: 4000 });

console.log(`ApolloServer listening at: ${url}`);
```

## Changed constructor options
We’ve changed the TypeScript names of the constructor options object from Config to ApolloServerOptions.

### `debug`

constructor option is now (mostly) `includeStackTracesInErrorResponses`

(it also doesn’t change the default log level of the logger from INFO to DEBUG in the case where you don’t provide your own logger any more)

## Changed Features

### New datasources plugin

As mentioned above, Apollo Server 4 drops the top-level [`dataSources`](https://www.apollographql.com/docs/apollo-server/data/data-sources) constructor option.

As part of the effort to produce clearer typing, the `apollo-datasource` package (with the `DataSource` abstract class) is no longer maintained. We have introduced a new `dataSourcePlugin` plugin for adding new datasources to your context.

<!--  TODO: What? -->
The `RESTDataSource` class will be published in a new package name (`@apollo/data-source-rest`? `@apollo/rest-data-source`?) (tbd)

The type returned from your context function matches the type available as context in your resolvers and plugins instead of the latter having an extra dataSources piece on it:
```ts
class MoviesAPI extends RESTDataSource {
  baseURL = 'https://movies-api.example.com/';
  private token: string;

  constructor(options: { token: string } & RESTDataSourceOptions) {
    super(options);  // this should send `cache` through
    this.token = options.token;
  }

  willSendRequest(request: RequestOptions) {
    request.headers.set('Authorization', this.token);
  }

  async getMovie(id: string): Movie {
    return this.get(`movies/${encodeURIComponent(id)}`);
  }
}

interface ContextValue {
  token: string;
  dataSources: {
    moviesAPI: MoviesAPI;
  }
};

const server = new ApolloServer<ContextValue>({
  typeDefs,
  resolvers,
});
await server.start();

app.use(expressMiddleware(server, {
  // (the ContextValue in the next line is actually inferred)
  context: ({ req }: {req: ExpressRequest }): ContextValue {
    const token = getTokenFromRequest(req);
    const { cache } = server;  // we'll make the cache field on `ApolloServer` public and readonly
    return {
      token,
      dataSources: {
        moviesAPI: new MoviesAPI({ cache, token }),
      },
    };
  },
}));
```

### We now use Fetcher from `@apollo/utils.fetcher` instead of `apollo-server-env` for Fetch API TypeScript typing

Semi-relatedly: removed `requestAgent` option from ApolloServerPluginUsageReporting

Instead of:
```
    ApolloServerPluginUsageReporting({ requestAgent })
```
You can write:
```
    import fetch from 'node-fetch';
    ApolloServerPluginUsageReporting({
      fetcher: (url, options) => fetch(url, {
        ...options,
        agent: requestAgent,
      }),
    });
```

### CSRF prevention (new in AS3.7) is on by default
By default, CSRF prevention is turned on in Apollo Server 4. For more information about CSRF prevention and CORS, see [Configuring CORS](/apollo-server/security/cors).

### ApolloServer’s generic argument is your context object type
???

### Context function is passed to your middleware-specific integration function (eg `expressMiddleware` or `standaloneServer`) instead of ApolloServer constructor

Previously ApolloServer is genericized on the arguments to the context
function rather the actual context object itself. We don't get type
inference into resolvers, inline plugins, etc.

Instead of passing context to the ApolloServer constructor at all, make
it an argument to the integration function. That way the arguments
aren't genericized; they are specific to the function you're calling.
Make the complete context object a parameter to the "execute this
request" function.

We found a lot of places that TContext wasn't threaded through types and
added it.

Now you can do stuff like:
```ts
  new ApolloServer<{ foo: number }>({
      Query: {
        n(_parent: any, _args: any, context): number {
          return context.foo;
        },
      },
    },
    plugins: [
      {
        async requestDidStart({ context }) {
          let n: number = context.foo;
        },
      },
      // Plugins declared to be <BaseContext> still work.
      ApolloServerPluginCacheControlDisabled(),
    ],
  });
```

#### `server.executeOperation` now takes a context *value* rather than arguments to pass to your context function.

This also simplifies executeOperation, where you just pass a context
object directly instead of arguments to your (probably already
fake-for-testing) context function.

We found that in practice, that’s what people actually wanted in tests. If you want to test the behavior of your context function, you can unit-test it directly.

### Change CacheScope enum to a pure type
Can’t write `CacheScope.public` anymore
- The enum CacheScope is now union of strings type
  - (scope: CacheScope.Private -> scope: 'PRIVATE')

## Combine many packages into a single @apollo/server

- apollo-server-core
- apollo-server (the "batteries-included" package)
- apollo-server-plugin-base
- apollo-server-types
- apollo-server-express
- apollo-server-errors
- apollo-reporting-protobuf

### Express API is now a function `expressMiddleware` instead of getMiddleware/applyMiddleware methods on a subclass of ApolloServer

<!-- link to /apollo-server/packages/server/src/express/index.ts -->
Moreover, there is no subclassing of ApolloServer at all.

`expressMiddleware` has no runtime dependency on `express` (or any other package) although `standaloneServer` does.

## Express middleware no longer tries to also work with Express’ predecessor project “Connect”

If anybody needs [Connect middleware](https://github.com/senchalabs/connect) it shouldn’t be hard to write it.


## Operation registry plugin has a new name
Use `@apollo/server-plugin-operation-registry` instead.

## HTTP handling changes
In JSON-encoded POST bodies, we expect variables and extensions (if provided) to be objects, not strings containing JSON string-ifications of objects

This works:
```
{“query”: “{ __typename }”, extensions: {“foo”: 1}}
```

And this does not:
```
{“query”: “{ __typename }”, extensions: “{\“foo\”: 1}”}
```

HTTP batching is disabled by default instead of enabled by default.

### HTTP batching as opt-in feature

## Plugin API changes

Remove schemaHash field from GraphQLRequestContext
This was a not particularly stable hash of the introspection JSON of a
schema. It was different from the hash of the schema SDL used by schema
reporting. It was created for the operation registry plugin but that
plugin hasn't used it for a while and it was only kept around for
backwards compatibility. So now it is gone.


Remove debug field from GraphQLRequestContext.

Remove persistedQueries field from GraphQLServiceContext

context field on GraphQLRequestContext is now contextValue (and in argument to willResolveField)


# Upcoming Stuff to Cover:
- Replace implementations of the cache interface with `keyv`
We no longer maintain `apollo-server-cache-memcached` or `apollo-server-cache-redis`. The interfaces and classes for `apollo-server-caching` are now in `@apollo/utils.keyvaluecache`
We now maintain (`@apollo/utils.keyv`) which wraps Keyv and lets you use their implementation of memcached and redis bindings (among others).
Existing implementations of `KeyValueCache` should continue to work.


- Explicit support in core for serverless-style startup error handling
- Move other plugins to their own repositories
- Change usage reporting defaults backwards-incompatibly to send less data
- Rethink ApolloError
- ApolloServer.logger should probably be public readonly in AS4
- Ensure errors thrown in context creation is handled in a helpful way
- Apollo Server plugins: expose server instance to plugins
- In general we just need to go over the full exported API and list what’s gone and where it’s gone
